#pragma config(Sensor, S1,     sonar,          sensorSONAR)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
#include "conf.txt"
#include "particleDataStructures.c"
#include "sample.h"

/* Variables used in our program */

int robotState = MOVE_STATE;
int leftEncodings = 0;
int rightEncodings = 0;


typedef struct {
	float x;
	float y;
	float angle; // -pi < angle < pi, 0 when robot pointed towards x+
} Position;
//*
Position position;

/* End variables used in our program */
/* Functions used in our program */

void stop()
{
	motor[LEFT_WHEEL] = 0;
	motor[RIGHT_WHEEL] = 0;
  wait1Msec(1000);
}

/* move time in millis based on K constant */
float get_move_time(float power, int distance) {
	return  (distance * 1.0) / (K * power);
}

void move_for_duration(int power, int time) {
	motor[LEFT_WHEEL] = power;
	motor[RIGHT_WHEEL] = power;
	wait1Msec(time);
	stop();
}

void move_forward(int power, float distance) {
	robotState = MOVE_STATE;

	motor[LEFT_WHEEL] = power;
	motor[RIGHT_WHEEL] = power;
	float time = get_move_time(power, distance);
	wait1Msec(time);
	stop();
}

/* Debugging variables */
void clear_debug_stats()
{
	nMotorEncoder[LEFT_WHEEL] = 0;
	nMotorEncoder[RIGHT_WHEEL] = 0;
}

void print_debug_stats()
{
	writeDebugStream("LEFT_WHEEL encoder: %d\n", nMotorEncoder[LEFT_WHEEL] );
	writeDebugStream("RIGHT_WHEEL encoder: %d\n", nMotorEncoder[RIGHT_WHEEL] );
	//clearDebugStats();
}
/* End debugging variables */

/* Distance related functions  */

float normalize_angle_value(float angle)
{
	if (angle > THETA_UPPER)
		return angle - THETA_NORMALIZER;
	if (angle < THETA_LOWER)
		return angle + THETA_NORMALIZER;

	return angle;
}

void position_add_distance(Position* p, float distance) {
	p->x += distance * cosDegrees(p->angle);
	p->y += distance * sinDegrees(p->angle);
	return;
}

void position_add_angle(Position* p, float deltaAngle) {
	if (DEBUG)
		writeDebugStream("Position_add_angle: Pos angle:%f adding angle:%f\n",p->angle, deltaAngle);
	p->angle = normalize_angle_value(p->angle + deltaAngle);
	if (DEBUG)
		writeDebugStream("Position_add_angle: Pos angle:%f\n",p->angle);
}

void rotate(float degs) {
	stop();
	robotState = ROTATE_STATE;
	PlaySound(soundDownwardTones);

	/* Might go wrong, opposite to what we have in our debug msg */
	int dir = (degs >= 0) - (degs < 0);
  motor[LEFT_WHEEL] 	= dir * ROTATE_POWER;
  motor[RIGHT_WHEEL] 	= -dir * ROTATE_POWER;
  wait1Msec(abs(degs) / 90 * ROTATE_90_TIME);
 	// End here

  position_add_angle(position, degs);
  stop();
}

/* functions related to points */

float distance(float x1, float y1, float x2, float y2)
{
	return sqrt((x1-x2) * (x1-x2) + (y1-y2) * (y1-y2));
}

float min(float a, float b)
{
	return a < b ? a : b;
}

float max(float a, float b)
{
	return a > b ? a : b;
}

float calculate_likelihood(float x, float y, float theta, float z)
{

	int closestWallIndex = -1;
	float shortestDistance = 20000.0;
	float m;
	int i = 0;

	for (i = 0; i < NUMBER_OF_WALLS; i++)
	{

		float a_x = wallAxArray[i], a_y = wallAyArray[i];
		float b_x = wallBxArray[i], b_y = wallByArray[i];
		m = ((b_y - a_y)*(a_x - x) - (b_x - a_x)*(a_y - y)) / ((b_y - a_y)*cosDegrees(theta) - (b_x - a_x)*sinDegrees(theta));

		float px = x + m*cosDegrees(theta);
		float py = y + m*sinDegrees(theta);

		if(px >= min(a_x,b_x) && px <= max(a_x,b_x) && py >= min(a_y,b_y) && py <= max(a_y,b_y) && m >= 0)
		{
			if ( m <= shortestDistance )
			{
				shortestDistance = m;
				closestWallIndex = i;
			}
		}

	}

	//writeDebugStream("[calculate_likelihood]: shortestDistance: %f \n", shortestDistance);
	//wait1Msec(10);
	float likelihood = exp(-pow(z - shortestDistance, 2) * 1.0 / (2 * pow(0.44, 2))) + 0.1;
	return likelihood;
}

void print_10_points()
{
	int i;
	for (i=0; i<10; ++i)
		writeDebugStream("x:%f y:%f theta:%f cos:%f, sin: %f\n",xArray[i], yArray[i], thetaArray[i],
																	cosDegrees(thetaArray[i]), sinDegrees(thetaArray[i]));
	writeDebugStream("-------------\n");
}

void points_update(float value, int state) {
	// Value is distance in cm when state is MOVE_STATE
	//and degrees when state is ROTATE_STATE
	int i;
	float e, f;

	switch (state) {
		case MOVE_STATE:
			for(i=0; i<NUMBER_OF_PARTICLES; i++) {
				e = sampleGaussian(0.0, 0.881);
				f = sampleGaussian(0.0, 0.881);
				xArray[i] = xArray[i] + (value + e) * cosDegrees(thetaArray[i]);
				yArray[i] = yArray[i] + (value + e) * sinDegrees(thetaArray[i]);
				thetaArray[i] = thetaArray[i] + f;
			}
			break;
		case ROTATE_STATE:
			for( i=0; i<NUMBER_OF_PARTICLES; i++) {

				e = sampleGaussian(0.0, 0.881);
				thetaArray[i] = normalize_angle_value(thetaArray[i] + value + e);
			}
			break;
	}
}

/* Start debug functions */
// Print the last 10 cumulative weight arrays
void print_10_cwa()
{
	writeDebugStream("Printing weights...\n");
	int i;
	for (i=NUMBER_OF_PARTICLES-11; i<NUMBER_OF_PARTICLES; ++i)
		writeDebugStream("wa[%d]: %f - cwa[%d]: %f\n",i,weightArray[i], i,cumulativeWeightArray[i]);
	writeDebugStream("-------------\n");
}
void print_100_cwa()
{
	writeDebugStream("Printing weights...\n");
	int i;
	for (i=0; i<NUMBER_OF_PARTICLES; ++i)
	{
		writeDebugStream("wa[%d]: %f - cwa[%d]: %f\n",i,weightArray[i], i,cumulativeWeightArray[i]);
		wait1Msec(50);
	}
	writeDebugStream("-------------\n");
}
/* End debug functions */


void calculate_cumulative_array()
{
	int i,j;


	// Creating the cumulative Weight Array
	for (i=0; i<NUMBER_OF_PARTICLES; ++i)
	{
		cumulativeWeightArray[i] = 0;
		for(j=0; j<= i; ++j)
			cumulativeWeightArray[i] += weightArray[j];
	}

	if (DEBUG)
		print_10_cwa();
}

void normalise_weight_array ()
{
	if (DEBUG)
		writeDebugStream("In normalise weight array\n");
	//print_10_cwa ();

	int i;
	float sum = 0.0;

	for (i = 0; i < NUMBER_OF_PARTICLES; ++i)
		sum += weightArray[i];

	if (DEBUG)
		writeDebugStream("Sum: %f\n",sum);

	for (i = 0; i < NUMBER_OF_PARTICLES; ++i)
		weightArray[i] /= sum;

	//print_10_cwa ();
	if (DEBUG)
		writeDebugStream("End normalise weight array\n");
}

int binary_search (float target)
{
	int begin = 0;
	int end = NUMBER_OF_PARTICLES - 1;
	int mid;

	while (begin <= end)
	{
		mid = (begin + end) / 2;
		if (target > cumulativeWeightArray[mid])
			begin = mid + 1;
		else if (target < cumulativeWeightArray[mid])
			end = mid - 1;
		else
			return mid;
	}
	return begin;
}

void resample()
{
	// Normalise weight array
	normalise_weight_array ();

	// Calculate cumulative array
	calculate_cumulative_array ();

	// Reset weights to 1/N
	int i;
	for (i = 0; i < NUMBER_OF_PARTICLES; ++i)
		weightArray[i] = 1.0 / NUMBER_OF_PARTICLES;

	if (DEBUG)
		print_100_cwa();
	// Resample
	for (i = 0; i < NUMBER_OF_PARTICLES; ++i)
	{
		// Generate random number between 0 and 1
	  unsigned int random_nr = 0;
	  random_nr = rand();
	  float random1 = random_nr * 1.0 / 65536;

		// Search value of random1 in cumulativeWeightArray
		int index = binary_search (random1);
		if (index == 100 )
			index = 99;
		//writeDebugStream("[Resample] random_nr: %d, random1: %f, BS: %d\n",random_nr, random1 ,index);
		// Copy new particle
		xArrayCopy[i] = xArray[index];
		yArrayCopy[i] = yArray[index];
	  thetaArrayCopy[i] = thetaArray[index];
	}

	// Update spacial distribution
	for (i = 0; i < NUMBER_OF_PARTICLES; ++i)
	{
		xArray[i] = xArrayCopy[i];
		yArray[i] = yArrayCopy[i];
		thetaArray[i] = thetaArrayCopy[i];
	}
}

void navigate_to_waypoint(float x, float y)
{
	float med_x = 0, med_y = 0, med_theta = 0;
	float i, z;

	writeDebugStream("Going towards point %f, %f\n",x,y);

	if (DEBUG)
	{
		print_10_points();
		print_10_cwa();
	}

    /* !!!!!!!!!!!!!!!!!! BUG HERE !!!!!!!!!!!!!!!!!!!!! */
	// estimate current posistion
	for (i=0; i < NUMBER_OF_PARTICLES; ++i)
	{
		med_x += xArray[i]*weightArray[i];
		med_y += yArray[i]*weightArray[i];
		med_theta += thetaArray[i]*weightArray[i];
	}
	writeDebugStream("Averages: x: %f y:%f theta:%f\n", med_x, med_y, med_theta);
    /* !!!!!!!!!!!!!!!!!! END BUG HERE !!!!!!!!!!!!!!!!!!!!! */

	// calculate difference
	float dif_x = x - med_x; // dest - curr_pos
	float dif_y = y - med_y;

	// Setting the dif_? thresholds
	if ( abs(dif_x) < 0.01 )
		dif_x = 0.0;
	if ( abs(dif_y) < 0.01 )
		dif_y = 0.0;

	writeDebugStream("Dif_x: %f, dif_y: %f\n",dif_x, dif_y);
	float rotate_degs;// = atan(dif_y / dif_x) * 180.0 / PI; // get the nr of degrees we want to turn. But in which direction ?!

	// Use of atan2
	if ( dif_x > 0)
		rotate_degs = atan (dif_y / dif_x);
	else if (dif_y >=0 && dif_x < 0)
		rotate_degs = atan( dif_y / dif_x) + PI;
	else if (dif_y < 0 && dif_x < 0)
		rotate_degs = atan (dif_y / dif_x) - PI;
	else if (dif_y > 0 && dif_x == 0)
		rotate_degs = PI;
	else if (dif_y < 0 && dif_x == 0)
		rotate_degs = -PI;
	else
		rotate_degs = 0;

	rotate_degs = rotate_degs * 180.0 / PI;
	rotate_degs = normalize_angle_value(rotate_degs - med_theta);
	writeDebugStream("Rotate angle: %f\n",rotate_degs);

	print_10_points();
	// Rotate towards the correct position
	rotate(rotate_degs);
	points_update(rotate_degs, ROTATE_STATE);
	print_10_points();

	// move forward
	float move_distance = sqrt(dif_x * dif_x + dif_y * dif_y);
	writeDebugStream("Moving distance: %f\n", move_distance);
	move_forward(MOVE_POWER, move_distance);

	// Update the position to the new points
	points_update(move_distance, MOVE_STATE);

	//wait1Msec(2000);
	PlaySound(soundBeepBeep);

	// Measure with sonar
	z = SensorValue[sonar];
	writeDebugStream("[Move_to_waypoint] %f\n",z);
	writeDebugStream("Before Calculate likelihood\n");
	print_10_cwa();
	for ( i = 0; i < NUMBER_OF_PARTICLES; i++ )
	{
		weightArray[i] = calculate_likelihood(xArray[i], yArray[i], thetaArray[i], z);
	}

	writeDebugStream("Before Resampling\n");
	print_10_cwa();
	// Resampling
	resample();
	writeDebugStream("After Resampling\n");
	print_10_cwa();

}
<<<<<<< HEAD
=======

void set_starting_position(float x, float y, float theta)
{
	position.x = x;
	position.y = y;
	position.angle = theta;

	int i;
	for (i=0; i < NUMBER_OF_PARTICLES; ++i)
	{
		xArray[i] = x;
		yArray[i] = y;
		thetaArray[i] = theta;
		// The sonar is gonna be initialized also
		weightArray[i] = 1.0 / NUMBER_OF_PARTICLES;
	}
}


>>>>>>> 3e5832e71739908534b2872549c34d412b138ace
/* End functions related to points */

/* Start task functions */
task vehicle_draw_position() {
	while (true) {
		wait1Msec(10);
		nxtSetPixel(20 + (int)(position.x / DISPLAY_SCALE), PRINT_OFFSET_Y + 20 + (int)(position.y / DISPLAY_SCALE));
	}
}

task vehicle_compute_position() {
	while (true) {
		wait1Msec(10);
		int curLeft = nMotorEncoder[LEFT_WHEEL];
		int curRight = nMotorEncoder[RIGHT_WHEEL];
		int deltaLeft = curLeft - leftEncodings;
		int deltaRight = curRight - rightEncodings;

		switch (robotState) {
			case MOVE_STATE:
				position_add_distance(&position, deltaLeft / ENCODINGS_PER_CM);
				break;
			case ROTATE_STATE:
			  // The angle will be added by the rotate function
				//addAngle(&position, deltaLeft / ENCODINGS_PER_DEGREE);
				break;
		}

		leftEncodings = curLeft;
		rightEncodings = curRight;
	}
}
/* End tasks */

<<<<<<< HEAD
void set_starting_position(float x, float y, float theta)
{
	position.x = x;
	position.y = y;
	position.angle = theta;

	int i;
	for (i=0; i < NUMBER_OF_PARTICLES; ++i)
	{
		xArray[i] = x;
		yArray[i] = y;
		thetaArray[i] = theta;
	}
}

=======
>>>>>>> 3e5832e71739908534b2872549c34d412b138ace
task main() {
	clearDebugStream();
	nMotorEncoder[LEFT_WHEEL] = 0;
	nMotorEncoder[RIGHT_WHEEL] = 0;

	bPlaySounds = true;
	set_starting_position(84.0, 30.0, 0.0);

	drawMap();

	StartTask(vehicle_compute_position);
	StartTask(vehicle_draw_position);

	navigate_to_waypoint(104, 30);
	drawParticles();
	navigate_to_waypoint(124, 30);
	drawParticles();
	navigate_to_waypoint(144, 30);
	drawParticles();
	navigate_to_waypoint(180, 30);
	drawParticles();
	navigate_to_waypoint(180, 54);
	drawParticles();
	navigate_to_waypoint(164, 54);
	drawParticles();
	navigate_to_waypoint(126, 54);
	drawParticles();
	// Moved left
	// Going up
	navigate_to_waypoint(126, 74);
	drawParticles();
	navigate_to_waypoint(126, 94);
	drawParticles();
	navigate_to_waypoint(126, 104);
	drawParticles();
	navigate_to_waypoint(126, 124);
	drawParticles();
	navigate_to_waypoint(126, 144);
	drawParticles();
	navigate_to_waypoint(126, 168);
	drawParticles();
	navigate_to_waypoint(126, 148);
	drawParticles();
	navigate_to_waypoint(126, 126);
	drawParticles();
	// From here, move in 20 cm ranges
	navigate_to_waypoint(30, 54);
	drawParticles();
	navigate_to_waypoint(84, 54);
	drawParticles();
	navigate_to_waypoint(84, 30);
	drawParticles();

  StopTask(vehicle_compute_position);
  StopTask(vehicle_draw_position);

  wait10Msec(60000); // wait 1MIN
}
