#pragma config(Sensor, S3,     sonar,          sensorSONAR)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

int DEFAULT_POWER = 100;
int LEFT_WHEEL = motorA;
int RIGHT_WHEEL = motorC;

/* end constants */

// global vars

void stop() {
	motor[LEFT_WHEEL] = 0;
	motor[RIGHT_WHEEL] = 0;
  // Now motors are synched
	//motor[RIGHT_WHEEL] = 0;
  wait1Msec(2000);
}

void clearDebugStats()
{
	//nMotorEncoder[LEFT_WHEEL] = 0;
	//nMotorEncoder[RIGHT_WHEEL] = 0;
}

void printDebugStats()
{
	writeDebugStream("LEFT_WHEEL encoder: %d\n", nMotorEncoder[LEFT_WHEEL] );
	writeDebugStream("RIGHT_WHEEL encoder: %d\n", nMotorEncoder[RIGHT_WHEEL] );
	clearDebugStats();
}

void enter_cubicle(int dir) {

	motor[RIGHT_WHEEL] = DEFAULT_POWER;
	motor[LEFT_WHEEL] = DEFAULT_POWER;
	int wheel;
	float radius = 21;
	float w = 17.7;

	float k = (radius - (w / 2.0))/(radius + (w / 2.0));

	wheel = (dir == -1 ? LEFT_WHEEL : RIGHT_WHEEL);

	motor[wheel] *= k;

	wait1Msec(268.65);

}

// dir = -1 (going east)
// dir = 1 (going west)
void follow_wall(int distance, int dir) {

	int wheel, diff, current_distance = 0;

	float k = 1;

	motor[RIGHT_WHEEL] = DEFAULT_POWER;
	motor[LEFT_WHEEL] = DEFAULT_POWER;

	while(current_distance < 60) {

		current_distance = SensorValue[sonar];

		writeDebugStream("Sensor reading: %d \n", current_distance);

		diff = distance - current_distance;
		if (diff < 0) {
			wheel = (dir == -1 ? LEFT_WHEEL : RIGHT_WHEEL);
			// set power of motor to turn towards wall
			motor[wheel] -= (int) (- k * diff);
			writeDebugStream("Value of diff: %f \n", diff);
			writeDebugStream("Wheel %d, motor 1: %d, motor 2: %d \n", wheel, motor[RIGHT_WHEEL], motor[LEFT_WHEEL]);

		} else {
			wheel = (dir == -1 ? RIGHT_WHEEL : LEFT_WHEEL);
			motor[wheel] -= (int) (- k * diff);
		}
		wait1Msec(30);
	}

}


task main()
{
	follow_wall(21, -1);
	enter_cubicle(-1);
	stop();
}
