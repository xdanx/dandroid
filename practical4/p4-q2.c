#pragma config(Sensor, S1,     touchRight,     sensorTouch)
#pragma config(Sensor, S2,     lightLeft,      sensorLightInactive)
#pragma config(Sensor, S3,     lightRight,     sensorCOLORNONE)
#pragma config(Sensor, S4,     touchLeft,      sensorTouch)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/* constants */
int ROTATE_90_TIME = 1210;
int ROTATE_POWER = 25;
int MOVE_POWER = 10;

const float K = 0.00036; // for distance in cm, and time in milliseconds

int LEFT_WHEEL = motorA;
int RIGHT_WHEEL = motorC;
int GUN = motorB;


#define MOVE_STATE 0
#define ROTATE_STATE 1
/* end constants */

// global vars

int robotState = MOVE_STATE;
int leftEncodings = 0;
int rightEncodings = 0;
int dir = 0;

/* Values read by the sensors */

int bumper_left = 0;
int bumper_right = 0;
int light_left = 0;
int light_right = 0;


/* Starting functions needed for controlling the robot */
void stop() {
	motor[LEFT_WHEEL] = 0;
	motor[RIGHT_WHEEL] = 0;
  wait1Msec(2000);
}

/* move time in millis based on K constant */
float getMoveTime(float power, int distance) {
	return  (distance * 1.0) / (K * power);
}

void move(int power, float distance) {
	robotState = MOVE_STATE;
	motor[LEFT_WHEEL] = power;
	motor[RIGHT_WHEEL] = power;
	float time = getMoveTime(abs(power), distance);
	wait1Msec(time);
	stop();
}

void rotate(int degs) {
	robotState = ROTATE_STATE;
	int dir = 1;
	if (degs < 0) {
		dir = -1;
		degs = -degs;
	}
	// Inverse the motors speed

  motor[LEFT_WHEEL] 	= dir * ROTATE_POWER;
  motor[RIGHT_WHEEL] 	= -dir * ROTATE_POWER;
  wait1Msec(degs * 1.0 / 90 * ROTATE_90_TIME);

  stop();
}

void addDistance(Position* p, float distance) {
	p->x += distance * cosDegrees(p->angle);
	p->y += distance * sinDegrees(p->angle);
	return;
}

void addAngle(Position* p, float deltaAngle) {
	const float upper = 180;
	const float lower = -180;
	p->angle += deltaAngle;
	if (p->angle > upper) p->angle -= 360;
	if (p->angle < lower) p->angle += 360;
}

/* End functions used to move robots */

#define TRU true

/* Our own functions here */


#define CENTERED_THRESHOLD 5


void light_centered()
{
	return ( (SensorValue[lightLeft] - SensorValue[lightRight]) < CENTERED_THRESHOLD &&
				  SensorValue[lightLeft] > CAPTURE_THRESHOLD && SensorValue[lightRight] > CAPTURE_THRESHOLD );
}

void light_unbalanced()
{
	return (SensorValue[lightLeft] > CAPTURE_THRESHOLD || SensorValue[lightRight] >  CAPTURE_THRESHOLD );
}


task balance_light()
{


}

task find_light()
{
	stop();



}


task main() {

	while (TRU)
	{
		if ( light_centered() )
		{
			continue;
		}
		else if ( light_unbalanced() )
		{
			// Here one sensor detects light, the other doesn't
			balance_light();
		}
		else
		{
			// We are not finding light, just look for a source of light
			find_light();
		}
	}

}
