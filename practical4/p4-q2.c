#pragma config(Sensor, S1,     touchRight,     sensorTouch)
#pragma config(Sensor, S2,     lightRight,     sensorLightInactive)
#pragma config(Sensor, S3,     lightLeft,      sensorCOLORNONE)
#pragma config(Sensor, S4,     touchLeft,      sensorTouch)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "conf.txt"

/* constants */
int LEFT_WHEEL = motorA;
int RIGHT_WHEEL = motorC;
int GUN = motorB;
/* end constants */

/* Starting functions needed for interacting with the robot */
void stop() {
	motor[LEFT_WHEEL] = 0;
	motor[RIGHT_WHEEL] = 0;
  wait1Msec(1000);
}

// This function gets the argument, to see in which direction the
// robot should move, 1 or -1

void rotate(int degs, int power) {
	int dir = 1;
	if (degs < 0) {
		dir = -1;
		degs = -degs;
	}

	// Inverse the motors speed
  motor[LEFT_WHEEL] 	= dir * power;
  motor[RIGHT_WHEEL] 	= -dir * power;
}

void dbg(char* s)
{
	//return;
	writeDebugStream("DEBUG: %s\n",s);
}


int get_left_light_sensor()
{
	// This sensor needs correction to be as the other one
	return SensorValue[lightLeft];
}
int get_right_light_sensor()
{
	// This sensor is returned as it is
	return SensorValue[lightRight];
}

void print_sensors()
{
	return;
	writeDebugStream("Left: %d - Right: %d\n", get_left_light_sensor(), get_right_light_sensor());
}

/* End functions used to interact with the robot */
/* Our own functions here */

bool light_centered()
{
	print_sensors();

	/* (	get_left_light_sensor() 	- LEFT_CENTERED_THRESHOLD -
						get_right_light_sensor() 	+ RIGHT_CENTERED_THRESHOLD < BOTH_CENTERED_THRESHOLD ) &&
	*/

	// Here the ( left sensor - left thresh ) - ( right sensor - right thresh ) < both centered

	return
				  (get_left_light_sensor() 	> LEFT_CENTERED_THRESHOLD ) &&
				  (get_right_light_sensor() > RIGHT_CENTERED_THRESHOLD ) ;
	/**/
}

int light_unbalanced()
{
	return (get_left_light_sensor() > LEFT_CAPTURE_THRESHOLD || get_right_light_sensor() >  RIGHT_CAPTURE_THRESHOLD );
}


void balance_light()
{
	dbg("Entered balance_light");
	print_sensors();
	// In this task, the light_unbalanced() condition holds
	if ( 	get_left_light_sensor()  - LEFT_CAPTURE_THRESHOLD >
				get_right_light_sensor() - RIGHT_CAPTURE_THRESHOLD )
		rotate(ROTATE_LEFT,BALANCE_ROTATE_POWER);
	else
		rotate(ROTATE_RIGHT,BALANCE_ROTATE_POWER);

}

void find_light()
{
	dbg("Entered find_light");
	rotate(ROTATE_LEFT,FIND_ROTATE_POWER);
}

void findThreshold()
{
	int lightValueLeft = 0;
	int lightValueRight = 0;
	int darkValueLeft = 0;
	int darkValueRight = 0;

	lightValueLeft = get_left_light_sensor();
	lightValueRight = get_right_light_sensor();

	dbg("remove light please");
	wait1Msec(2000);

	darkValueLeft = get_left_light_sensor();
	darkValueRight = get_right_light_sensor();

	LEFT_CAPTURE_THRESHOLD = (lightValueLeft + lightValueRight)/2;
	RIGHT_CAPTURE_THRESHOLD = (lightValueLeft + lightValueRight)/2;
}

task main()
{
	findThreshold();
	while (TRU)
	{
		//dbg("Starting while loop");
		if ( light_centered() )
		{
			dbg("Entered light centered");
			stop();
			continue;
		}
		else if ( light_unbalanced() )
		{
			// Here one sensor detects light, the other doesn't
			balance_light();
		}
		else
		{
			// We are not finding light, just look for a source of light
			find_light();
		}
	}


}
