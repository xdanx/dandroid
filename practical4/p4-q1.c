#pragma config(Sensor, S1,     touchRight,     sensorTouch)
#pragma config(Sensor, S2,     lightLeft,      sensorLightInactive)
#pragma config(Sensor, S3,     lightRight,     sensorCOLORNONE)
#pragma config(Sensor, S4,     touchLeft,      sensorTouch)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "conf.txt"

int LEFT_WHEEL = motorA;
int RIGHT_WHEEL = motorC;
int GUN = motorB;


/* Starting functions needed for controlling the robot */
void stop() {
	motor[LEFT_WHEEL] = 0;
	motor[RIGHT_WHEEL] = 0;
  wait1Msec(1000);
}

void move(int power) {

	motor[LEFT_WHEEL] = power;
	motor[RIGHT_WHEEL] = power;

}

void right_curve(int power) {
	motor[LEFT_WHEEL] = 1.2*power;
	motor[RIGHT_WHEEL] = power;

	wait1Msec(5000);

	stop();
}

void left_curve(int power) {
	motor[LEFT_WHEEL] = power;
	motor[RIGHT_WHEEL] = 1.2*power;

	wait1Msec(5000);
	stop();
}

void move_back() {
	motor[LEFT_WHEEL] = -DEFAULT_POWER;
	motor[RIGHT_WHEEL] = -DEFAULT_POWER;

	wait1Msec(3000);

	stop();
}

void rotate(int dir, int power) {
	// Inverse the motors speed
  motor[LEFT_WHEEL] 	= dir * power;
  motor[RIGHT_WHEEL] 	= -dir * power;

}

void dbg(char* s)
{
	writeDebugStream("%s\n",s);
}

/* End functions used to move robots */

void avoid_obstacle()
{
	dbg("DEBUG: Started task avoid_obstacle\n");

	// Read the values reported by the sensors
	int left_bump = SensorValue[touchLeft];
	int right_bump = SensorValue[touchRight];

	dbg("Moving back");
	//reverse
	move_back();

	if ( left_bump == 1 && right_bump == 1 )
	{
		dbg("Hit was centered");
		//hit was center
		rotate(ROTATE_LEFT, DEFAULT_POWER);
		wait1Msec(500);
		//left_curve(DEFAULT_POWER);

	} else if (right_bump == 1)
	{
		dbg("Hit was right");
		//hit was right
		rotate(ROTATE_LEFT, DEFAULT_POWER);
		wait1Msec(500);
		//left_curve(DEFAULT_POWER);

	} else
	{
		dbg("Hit was left");
		//hit was left
		rotate(ROTATE_RIGHT, DEFAULT_POWER);
		wait1Msec(500);
		//right_curve(DEFAULT_POWER);

	}
}

int bumped()
{
	// Return if either left or right bump
	return SensorValue[touchLeft] || SensorValue[touchRight];
}


task main() {

	while (TRU)
	{
		if ( bumped() )
		{
			stop();
			// Start the avoid obstacle turn
			avoid_obstacle();
		}
		else {
			move(DEFAULT_POWER);
		}
	}

}
