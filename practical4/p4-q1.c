#pragma config(Sensor, S1,     touchRight,     sensorTouch)
#pragma config(Sensor, S2,     lightLeft,      sensorLightInactive)
#pragma config(Sensor, S3,     lightRight,     sensorCOLORNONE)
#pragma config(Sensor, S4,     touchLeft,      sensorTouch)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

int LEFT_WHEEL = motorA;
int RIGHT_WHEEL = motorC;
int GUN = motorB;
int DEFAULT_POWER = 20;

/* Starting functions needed for controlling the robot */
void stop() {
	motor[LEFT_WHEEL] = 0;
	motor[RIGHT_WHEEL] = 0;
  wait1Msec(2000);
}

void move(int power) {

	motor[LEFT_WHEEL] = power;
	motor[RIGHT_WHEEL] = power;

}

void rightCurve() {
	motor[LEFT_WHEEL] = DEFAULT_POWER;
	motor[RIGHT_WHEEL] = 1.8*DEFAULT_POWER;

	wait1Msec(4000);

	stop();
}

void leftCurve() {
	motor[LEFT_WHEEL] = 1.8*DEFAULT_POWER;
	motor[RIGHT_WHEEL] = DEFAULT_POWER;

	wait1Msec(4000);

	stop();
}

void moveBack() {
	motor[LEFT_WHEEL] = -DEFAULT_POWER;
	motor[RIGHT_WHEEL] = -DEFAULT_POWER;

	wait1Msec(3000);

	stop();
}

void dbg(char* s)
{
	writeDebugStream("%s\n",s);
}

/* End functions used to move robots */

#define TRU true

void avoid_obstacle() {

	dbg("DEBUG: Started task avoid_obstacle\n");


	// Read the values reported by the sensors
	int left_bump = SensorValue[touchLeft];
	int right_bump = SensorValue[touchRight];

	dbg("Moving back");
	//reverse
	moveBack();

	if ( left_bump == 1 && right_bump == 1 )
	{
		dbg("Hit was centered");
		//hit was center
		leftCurve();

	} else if (right_bump == 1)
	{
		dbg("Hit was right");
		//hit was right
		leftCurve();

	} else
	{
		dbg("Hit was left");
		//hit was left
		rightCurve();

	}
}

int bumped()
{
	// Return if either left or right bump
	return SensorValue[touchLeft] || SensorValue[touchRight];
}


task main() {

	while (TRU)
	{
		if ( bumped() )
		{
			stop();
			// Start the avoid obstacle turn
			avoid_obstacle();
		}
		else {
			move(DEFAULT_POWER);
		}
	}

}
